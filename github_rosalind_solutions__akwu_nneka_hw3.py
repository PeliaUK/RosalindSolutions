# -*- coding: utf-8 -*-
"""GITHUB_Rosalind Solutions _Akwu  Nneka HW3

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1jVhMp0OXAfFDzacyRU6AEbCatn3GIhb9

#**SUBS**

#**Finding a Motif in DNA**

#Combing Through the Haystack
Finding the same interval of DNA in the genomes of two different organisms (often taken from different species) is highly suggestive that the interval has the same function in both organisms.

We define a motif as such a commonly shared interval of DNA. A common task in molecular biology is to search an organism's genome for a known motif.

The situation is complicated by the fact that genomes are riddled with intervals of DNA that occur multiple times (possibly with slight modifications), called repeats. These repeats occur far more often than would be dictated by random chance, indicating that genomes are anything but random and in fact illustrate that the language of DNA must be very powerful (compare with the frequent reuse of common words in any human language).

The most common repeat in humans is the Alu repeat, which is approximately 300 bp long and recurs around a million times throughout every human genome (see Figure 1). However, Alu has not been found to serve a positive purpose, and appears in fact to be parasitic: when a new Alu repeat is inserted into a genome, it frequently causes genetic disorders.

Given two strings s
 and t
, t
 is a substring of s
 if t
 is contained as a contiguous collection of symbols in s
 (as a result, t
 must be no longer than s
).

The position of a symbol in a string is the total number of symbols found to its left, including itself (e.g., the positions of all occurrences of 'U' in "AUGCUUCAGAAAGGUCUUACG" are 2, 5, 6, 15, 17, and 18). The symbol at position i
 of s
 is denoted by s[i]
.

A substring of s
 can be represented as s[j:k]
, where j
 and k
 represent the starting and ending positions of the substring in s
; for example, if s
 = "AUGCUUCAGAAAGGUCUUACG", then s[2:5]
 = "UGCU".

The location of a substring s[j:k]
 is its beginning position j
; note that t
 will have multiple locations in s
 if it occurs more than once as a substring of s
 (see the Sample below).

Given: Two DNA strings s
 and t
 (each of length at most 1 kbp).

Return: All locations of t
 as a substring of s
.
Sample Dataset
GATATATGCATATACTT
ATAT
Sample Output
2 4 10
"""

# Data set input
s = "GATATATGCATATACTT"
t = "ATAT"
def find_substring_locations(s, t):
    locations = []
    t_length = len(t)

    # Iterate through the string s
    for i in range(len(s) - t_length + 1):
        # Check if the substring matches
        if s[i:i + t_length] == t:
            # Store the 1-based index
            locations.append(i + 1)

    return locations

# Find and print the locations
locations = find_substring_locations(s, t)
print(" ".join(map(str, locations)))

"""#**PRTM**

## Calculating Protein Mass

###Chaining the Amino Acids
In “Translating RNA into Protein”, we examined the translation of RNA into an amino acid chain for the construction of a protein. When two amino acids link together, they form a peptide bond, which releases a molecule of water; see Figure 1. Thus, after a series of amino acids have been linked together into a polypeptide, every pair of adjacent amino acids has lost one molecule of water, meaning that a polypeptide containing n
 amino acids has had n−1
 water molecules removed.

More generally, a residue is a molecule from which a water molecule has been removed; every amino acid in a protein are residues except the leftmost and the rightmost ones. These outermost amino acids are special in that one has an "unstarted" peptide bond, and the other has an "unfinished" peptide bond. Between them, the two molecules have a single "extra" molecule of water (see the atoms marked in blue in Figure 2). Thus, the mass of a protein is the sum of masses of all its residues plus the mass of a single water molecule.

There are two standard ways of computing the mass of a residue by summing the masses of its individual atoms. Its monoisotopic mass is computed by using the principal (most abundant) isotope of each atom in the amino acid, whereas its average mass is taken by taking the average mass of each atom in the molecule (over all naturally appearing isotopes).

Many applications in proteomics rely on mass spectrometry, an analytical chemical technique used to determine the mass, elemental composition, and structure of molecules. In mass spectrometry, monoisotopic mass is used more often than average mass, and so all amino acid masses are assumed to be monoisotopic unless otherwise stated.

The standard unit used in mass spectrometry for measuring mass is the atomic mass unit, which is also called the dalton (Da) and is defined as one twelfth of the mass of a neutral atom of carbon-12. The mass of a protein is the sum of the monoisotopic masses of its amino acid residues plus the mass of a single water molecule (whose monoisotopic mass is 18.01056 Da).

In the following several problems on applications of mass spectrometry, we avoid the complication of having to distinguish between residues and non-residues by only considering peptides excised from the middle of the protein. This is a relatively safe assumption because in practice, peptide analysis is often performed in tandem mass spectrometry. In this special class of mass spectrometry, a protein is first divided into peptides, which are then broken into ions for mass analysis.

##Problem
In a weighted alphabet, every symbol is assigned a positive real number called a weight. A string formed from a weighted alphabet is called a weighted string, and its weight is equal to the sum of the weights of its symbols.

The standard weight assigned to each member of the 20-symbol amino acid alphabet is the monoisotopic mass of the corresponding amino acid.

Given: A protein string P
 of length at most 1000 aa.

Return: The total weight of P
. Consult the monoisotopic mass table.

Sample Dataset
SKADYEK
Sample Output
821.392

#**SPLC**

##RNA Splicing

###Genes are Discontiguousclick to collapse

Figure 1. The elongation of a pre-mRNA by RNAP as it moves down the template strand of DNA.

Figure 2. RNA is identical to the coding strand except for the replacement of thymine with uracil.
In “Transcribing DNA into RNA”, we mentioned that a strand of DNA is copied into a strand of RNA during transcription, but we neglected to mention how transcription is achieved.

In the nucleus, an enzyme (i.e., a molecule that accelerates a chemical reaction) called RNA polymerase (RNAP) initiates transcription by breaking the bonds joining complementary bases of DNA. It then creates a molecule called precursor mRNA, or pre-mRNA, by using one of the two strands of DNA as a template strand: moving down the template strand, when RNAP encounters the next nucleotide, it adds the complementary base to the growing RNA strand, with the provision that uracil must be used in place of thymine; see Figure 1.

Because RNA is constructed based on complementarity, the second strand of DNA, called the coding strand, is identical to the new strand of RNA except for the replacement of thymine with uracil. See Figure 2 and recall “Transcribing DNA into RNA”.

After RNAP has created several nucleotides of RNA, the first separated complementary DNA bases then bond back together. The overall effect is very similar to a pair of zippers traversing the DNA double helix, unzipping the two strands and then quickly zipping them back together while the strand of pre-mRNA is produced.

For that matter, it is not the case that an entire substring of DNA is transcribed into RNA and then translated into a peptide one codon at a time. In reality, a pre-mRNA is first chopped into smaller segments called introns and exons; for the purposes of protein translation, the introns are thrown out, and the exons are glued together sequentially to produce a final strand of mRNA. This cutting and pasting process is called splicing, and it is facilitated by a collection of RNA and proteins called a spliceosome. The fact that the spliceosome is made of RNA and proteins despite regulating the splicing of RNA to create proteins is just one manifestation of a molecular chicken-and-egg scenario that has yet to be fully resolved.

In terms of DNA, the exons deriving from a gene are collectively known as the gene's coding region.

Problem
After identifying the exons and introns of an RNA string, we only need to delete the introns and concatenate the exons to form a new string ready for translation.

Given: A DNA string s
 (of length at most 1 kbp) and a collection of substrings of s
 acting as introns. All strings are given in FASTA format.

Return: A protein string resulting from transcribing and translating the exons of s
. (Note: Only one solution will exist for the dataset provided.)

Sample Dataset
>Rosalind_10
ATGGTCTACATAGCTGACAAACAGCACGTAGCAATCGGTCGAATCTCGAGAGGCATATGGTCACATGATCGGTCGAGCGTGTTTCAAAGTTTGCGCCTAG
>Rosalind_12
ATCGGTCGAA
>Rosalind_15
ATCGGTCGAGCGTGT
Sample Output
MVYIADKQHVASREAYGHMFKVCA
"""

seq = 'ATGTTCCGGTTCACGTACAGGCGCACTACTTTGCCAGACATCTGTGTCCCATGAACGGCACCACGAACCACACGGCAATGGTACTACAGTCAGTCCGCCTGATGGAGTATGTAACAGCTCCCGCCTGACCACTTTAAAATCGTTCATATTTGAGTATTCCGAGTCATTAGGCTGTAGCTCCCCTGCTAGCCGTCGGGTAAAGTCGTCCAACGCCCTTGCAGGAGGGTGTGAGATCCTTGCGATCCACGGATGTTACGGGCTCGGTTGCAGTCGGCCGTGGTGAAAAGCCTCCGAAGTTCTGGAATTCGCCTGTGCGCAACCCATGGAGGCAGGTTCAGCGGATCCCTTCCGGCCAAGATAACTGAGCGAACAAAAATCCACAGACACGATACCGAGTCTGTCTGCGTACGACACTTGCGATTTACGACCTCGGCGATAAGTAGAAGAAAACGCTGCTGTGTCGGGCAATCGCGTCACAACCTATGAACATAATGGTATATGGGATCTGGCGGGCACATGCAGAAGGCAATACCCCCCGCCTAACCTCATGCTCCTGCTAGAGCCAAGATGGGGTGCCCTACCGGAACTTCGCGCATTAGTGTGTCGCTAATAGACCCCCCCATCTGACGGCCCACATATGCGACAGTCGCGTCTTACTACATGGCTACCCGATAGGGGACCCCTTACTTCCCCGCGTTTCGGCTCGTATCAAAGGAAGCGAACCGGTTTAATAGCTTGATGGTCTCAATCATGGAACATATGATGCGCAGTTATACTTATAGGCGGCGTCACACTGACTGTTATCATCCTTCCGTAATAAGCCGGATCAGGTTACTTGTCACGTTGGCAAGATCAGTGGAGATTCTGTTTCGCGATTGGTACCGATCGGATATCAATTCAGGTTTCCGGGGAACCGTGCCTGGGCCTACAATCTGAAGACTGTGTGATGTTGGCGTCGTCTCCAAGCTCGTCCCCAGAATTATGAGAACAGGTCCCCCGTCTCTTCTACCAAACATGCACACATACCAGGATTGAACACCGCTGCATCTGCACGTTCTGTGTGTTTGTTAAGGCTTGGAGCTTTTTGGGACAGACGCCATATTCGCTAAGAACTAGGCCAGGTAGTTATGTTTGAACACACCCCGGGTAGTCAAACAGTTGTAATAATACAAAAAGGTTAGGGTATCCGTCGCGCTTCGGTTTAACTGTGAAATCCACAATCTGCCGACGAAACGTGCTCGTGGATGGGCGAAACCCCATCTTCACTGAATCCTATCTTCACGGGAAGACGCCCATCAATACAAACTCGGGTTATTTACACCTACCATTGGGGATTCCTTCCCCACGTCCACCATCCGAGGCCGGCGATGGAGCGCTCGGTCTCCGTCAACTGGCCTTATCCGCCTAGCTCCGACTATCACTTGCGTGTTGACCCGTTACCTCGTGCAAACACGTGCAACGGGCCCTTGGCCTAGGGGCACGTACTCAGCTCGCCCTCGGCTCGAAAGCTTTTTCTCGGTGTCCCCTCCTCGCTACATGCTTCAGCGTAACGAATCAAGTTGAAAGTGTTGACCATATCTCGCTGCCAGAGTAGACTATAAGCAGCATAGGGGTCAGATGGTCCATCTCAACGACTTGCCTGGAAACTGCACCAACTTTACCCACGCAACATGAGCACTACCCGGTCAAGGGGAAAATCATCGGATCTACGAGAACGGCATTTATACTTCTATCAGAGCTTCTAGTAGTAATCGTACCAAAATGATGTTCGCGGGAGGCCCTTCACTTTTATCCTCGGAGGGGGGAGCGCCTTCGATCCGCGAGCATATGAGACGCAAGTCTGAGGTTCGTACTGTAG'

intron_1="CAGGTTACTTGTCACGTTGGCAAGATCAGTGG"
intron_2="GCACATGCAGAAGGCAATACCCCCCGCCTAACCTCATG"
intron_3="GGCTGTAGCTCCCCTGCTAGCCG"
intron_4="TGAGCGAACAAAAATCCACAGACACGATAC"
intron_5="TATACTTATAGGCGGCGTCACACTGACTG"
intron_6="TGTAACAGCTCCCGCCTG"
intron_7="CCTGTGCGCAACCCATGGAGGCAGGTTCAGCGGATCCCT"
intron_8="CTCGGCGATAAGTAGAAGAAAACGCTG"
intron_9="CGCCCTTGCAGGAGGGTGTGAGATCCTTGCGATCCACGGATGTTACG"
intron_10="TAATAGACCCCCC"
intron_11="CCATGAACGGCACCACGAACCACACGGCAATGGT"
intron_12="GAACCGTGCCTG"
intron_13="CCCTTACTTCCCCGCGTTTCGGCTCGTATCAAAGGAAGCGAACCGG"





#remove introns
for i in [intron_1, intron_2]:
    seq = seq.replace(i, '')

# Translate DNA to RNA
def trans(seq):
    return seq.replace('T', 'U')

# Dictionary
code = {
    'UUU': 'F', 'CUU': 'L', 'AUU': 'I', 'GUU': 'V',
    'UUC': 'F', 'CUC': 'L', 'AUC': 'I', 'GUC': 'V',
    'UUA': 'L', 'CUA': 'L', 'AUA': 'I', 'GUA': 'V',
    'UUG': 'L', 'CUG': 'L', 'AUG': 'M', 'GUG': 'V',
    'UCU': 'S', 'CCU': 'P', 'ACU': 'T', 'GCU': 'A',
    'UCC': 'S', 'CCC': 'P', 'ACC': 'T', 'GCC': 'A',
    'UCA': 'S', 'CCA': 'P', 'ACA': 'T', 'GCA': 'A',
    'UCG': 'S', 'CCG': 'P', 'ACG': 'T', 'GCG': 'A',
    'UAU': 'Y', 'CAU': 'H', 'AAU': 'N', 'GAU': 'D',
    'UAC': 'Y', 'CAC': 'H', 'AAC': 'N', 'GAC': 'D',
    'UAA': 'Stop', 'CAA': 'Q', 'AAA': 'K', 'GAA': 'E',
    'UAG': 'Stop', 'CAG': 'Q', 'AAG': 'K', 'GAG': 'E',
    'UGU': 'C', 'CGU': 'R', 'AGU': 'S', 'GGU': 'G',
    'UGC': 'C', 'CGC': 'R', 'AGC': 'S', 'GGC': 'G',
    'UGA': 'Stop', 'CGA': 'R', 'AGA': 'R', 'GGA': 'G',
    'UGG': 'W', 'CGG': 'R', 'AGG': 'R', 'GGG': 'G'}

rna = trans(seq)

# Translate RNA into a protein sequence
protein = []
count = 0

while count < len(rna):
    codon = rna[count:count + 3]
    if len(codon) < 3:
        break
    amino_acid = code.get(codon, None)
    if amino_acid == 'Stop':
        break
    if amino_acid:
        protein.append(amino_acid)
    count += 3

protein = ''.join(protein)

# Print outputs
print("DNA sequence after intron remove:", seq)
print("Processed RNA sequence:", rna)
print("Protein sequences:", protein)

seq = 'ATGGTCTACATAGCTGACAAACAGCACGTAGCAATCGGTCGAATCTCGAGAGGCATATGGTCACATGATCGGTCGAGCGTGTTTCAAAGTTTGCGCCTAG'

intron_1="ATCGGTCGAA"
intron_2="ATCGGTCGAGCGTGT"



#remove introns
for i in [intron_1, intron_2]:
    seq = seq.replace(i, '')

# Translate DNA to RNA
def trans(seq):
    return seq.replace('T', 'U')

# Dictionary
code = {
    'UUU': 'F', 'CUU': 'L', 'AUU': 'I', 'GUU': 'V',
    'UUC': 'F', 'CUC': 'L', 'AUC': 'I', 'GUC': 'V',
    'UUA': 'L', 'CUA': 'L', 'AUA': 'I', 'GUA': 'V',
    'UUG': 'L', 'CUG': 'L', 'AUG': 'M', 'GUG': 'V',
    'UCU': 'S', 'CCU': 'P', 'ACU': 'T', 'GCU': 'A',
    'UCC': 'S', 'CCC': 'P', 'ACC': 'T', 'GCC': 'A',
    'UCA': 'S', 'CCA': 'P', 'ACA': 'T', 'GCA': 'A',
    'UCG': 'S', 'CCG': 'P', 'ACG': 'T', 'GCG': 'A',
    'UAU': 'Y', 'CAU': 'H', 'AAU': 'N', 'GAU': 'D',
    'UAC': 'Y', 'CAC': 'H', 'AAC': 'N', 'GAC': 'D',
    'UAA': 'Stop', 'CAA': 'Q', 'AAA': 'K', 'GAA': 'E',
    'UAG': 'Stop', 'CAG': 'Q', 'AAG': 'K', 'GAG': 'E',
    'UGU': 'C', 'CGU': 'R', 'AGU': 'S', 'GGU': 'G',
    'UGC': 'C', 'CGC': 'R', 'AGC': 'S', 'GGC': 'G',
    'UGA': 'Stop', 'CGA': 'R', 'AGA': 'R', 'GGA': 'G',
    'UGG': 'W', 'CGG': 'R', 'AGG': 'R', 'GGG': 'G'}

rna = trans(seq)

# Translate RNA into a protein sequence
protein = []
count = 0

while count < len(rna):
    codon = rna[count:count + 3]
    if len(codon) < 3:
        break
    amino_acid = code.get(codon, None)
    if amino_acid == 'Stop':
        break
    if amino_acid:
        protein.append(amino_acid)
    count += 3

protein = ''.join(protein)

# Print outputs
print("DNA sequence after intron remove:", seq)
print("Processed RNA sequence:", rna)
print("Protein sequences:", protein)

"""#**REVP**

##Locating Restriction Sites

###The Billion-Year Warclick to expand


The war between viruses and bacteria has been waged for over a billion years. Viruses called bacteriophages (or simply phages) require a bacterial host to propagate, and so they must somehow infiltrate the bacterium; such deception can only be achieved if the phage understands the genetic framework underlying the bacterium's cellular functions. The phage's goal is to insert DNA that will be replicated within the bacterium and lead to the reproduction of as many copies of the phage as possible, which sometimes also involves the bacterium's demise.

To defend itself, the bacterium must either obfuscate its cellular functions so that the phage cannot infiltrate it, or better yet, go on the counterattack by calling in the air force. Specifically, the bacterium employs aerial scouts called restriction enzymes, which operate by cutting through viral DNA to cripple the phage. But what kind of DNA are restriction enzymes looking for?

The restriction enzyme is a homodimer, which means that it is composed of two identical substructures. Each of these structures separates from the restriction enzyme in order to bind to and cut one strand of the phage DNA molecule; both substructures are pre-programmed with the same target string containing 4 to 12 nucleotides to search for within the phage DNA (see Figure 1.). The chance that both strands of phage DNA will be cut (thus crippling the phage) is greater if the target is located on both strands of phage DNA, as close to each other as possible. By extension, the best chance of disarming the phage occurs when the two target copies appear directly across from each other along the phage DNA, a phenomenon that occurs precisely when the target is equal to its own reverse complement. Eons of evolution have made sure that most restriction enzyme targets now have this form.

Problem

Figure 2. Palindromic recognition site
A DNA string is a reverse palindrome if it is equal to its reverse complement. For instance, GCATGC is a reverse palindrome because its reverse complement is GCATGC. See Figure 2.

Given: A DNA string of length at most 1 kbp in FASTA format.

Return: The position and length of every reverse palindrome in the string having length between 4 and 12. You may return these pairs in any order.

Sample Dataset
>Rosalind_24
TCAATGCATGCGGGTCTATATGCAT
Sample Output
4 6
5 4
6 6
7 4
17 4
18 4
20 6
21 4
"""

#Dataset
seq = "CGCGAGGGTGCAAAAGCTGCGGTTTTGAGATCTTGACTCGTATGTTATCACAGTAGTCGAAAGGTCACGATTGCGCATGTTCTACTTGCGACTGTATAAGATTCTTTATAAATCCACACATTTAGAGATCGTGGGCACAGGGCACGAGATATTCGCCTAATAAAGAGTTACTAAAAACCGGAATCCATCTCAGAACTTAAATCGAATCAAGGTTCGATAAGGGAGAGATTACGCATCGCAGATTCTAGCTCGAGCTCTATCTTCCCCACGAGGACCCCTATGAGGTAGGATAGTTGAGTTCCCCCCTCCTCTTCTTGGCTTTAGTGCTGAACGATATTCCTATTATTACAGCGCCGACGGGCGATCCTGCTATCTACAACTTGCTATGGATGAAAAACCGGAGAACTACTGGAATTCCAGTATATGCGAGCAGAAAACGGTTAAGAGAGCGGATACAGACTATAGAAGCTCGAGTGACCGCGGCGATCCGGAACCTCGAACAGGGTCCCCGCTGCAAAACGTGTGGTCCCAATACATGAGACAATAATCGTTTGTTTGTAACAGCTAGTGCGGAGAGCGCGGCTACTAGCAAATAATACAGTAGCAAAGAAGAAATAGCTGACTCGCTGTAGTACCACAAACACTAACAGGGGCGGTCTCGGCATACTTTTAAGTCTGTCTTGAAATGGTGTTCCAATTGGCTCACATCCCCCGTATCGAGCTCATCTAGGGCATTCCCAGCGTACGGAGGAGTCTGTCCATACCGGGTACCAGACCGCATGAGACTAACGCCCCTCGCTTGTTAGAGGCTGTGGGGGGCGCATCGCG"
def restriction(DNA):
    Result = []
    complement = str.maketrans('ATCG', 'TAGC')  # Translation table for complement DNA strand

    for nuc in range(len(DNA) - 3):  # Ensure we check all substrings of min length 4
        for length in range(4, 13):  # Palindromic lengths from 4 to 12
            if nuc + length > len(DNA):
                break

            sub_seq = DNA[nuc:nuc+length]
            reverse = sub_seq.translate(complement)[::-1]  # reverse complement

            if sub_seq == reverse:  # Check if palindrome
                Result.append([nuc+1, length])

    for pos, length in Result:
        print(pos, length)



restriction(seq)

"""#**TRAN**

##Transitions and Transversions

####The Genetic Codeclick to expand
Problem
The 20 commonly occurring amino acids are abbreviated by using 20 letters from the English alphabet (all letters except for B, J, O, U, X, and Z). Protein strings are constructed from these 20 symbols. Henceforth, the term genetic string will incorporate protein strings along with DNA strings and RNA strings.

The RNA codon table dictates the details regarding the encoding of specific codons into the amino acid alphabet.

Given: An RNA string s
 corresponding to a strand of mRNA (of length at most 10 kbp).

Return: The protein string encoded by s
.

Sample Dataset
AUGGCCAUGGCGCCCAGAACUGAGAUCAAUAGUACCCGUAUUAACGGGUGA
Sample Output
MAMAPRTEINSTRING
"""

# dataset
rna_string = "AUGCCAAACCGCACAGUCCCCUCCCAGUCUCUGGUACUGCAUAGAUUUGGUAAAUACCGCCGCAGCCUUUUAAGCACCGUCUCCGGCGAUUGCAUUCCUGCAUACACCCAUGCCUCAUUUGGAUGGCGCCUACUCGGGGAGCCGCGGGACCUUUUCAUUUGGCGAAGCCCGACCGUGUGGUUCCGCUCGAACACGAAGUCAUAUGCAAUAAGUAUUACAGUUCGCUUAAGAGACGCGGAACCAGGCGACUUGCCAAAGGCGGGUGCGAUCACUGGAUUGGACCAAGGCAGUGAAUUCGCGCAAAACAAGACGAUGCCAAUUCUCAUCUCUCACCAAUUCGCAUCUUCCCUAGGUCAUUGGUCGACGCGUAUACUUCAUGGGGCCCCUGACUUUAGUUUCGAAUGUGGCCUACUCGCCACGAGCGUACGCGGUCCGGCUCAUGACAGAAGGCCGUGGUCCAGACGGUUCCCAAUAUCUUUACACGAUCAGGAUUUCAGUCAGCAAGACGCAAGUGCCUGCACUUGCUCGCCCAUACGACCACAGCCCCUAAGCCGAUGUUGCUCACCUCAUCCUAAGUCUGAGGGAACCUCACUAUCCAAACUUAAAUUGGGCCAGCCCCGAACAGACUAUAGGCUGCACGCCAUCGCUAGUACAAUCAUAUUCCCAUUAAGGUGCGCCUCGUGCCAUCGCGGUGUUUACUUUUCAGUGCCGAAGCUAGUGGCCUCGACGAGUCAAAUUAGCCAUAAUAGGCCUGUCUAUGCACGAUUUGUACCCCUCGAACCAAAUCACUUGGUGCCACACCACAACGCGCUACGCAAUUCCCUAUCGGAGGCUGUCGUCAUGAGCGUUAGCCGAUCCCAGGGGGCGUUGCGUGAUAAAUCCUCCGUAUCGGAAUCACGAAACAAAGGGUGUAGAUAUAUACACCAAAGUACCCAGGGGGCUGUGCGGGAUGUGCGGGAGAGUCAUAAGCUCGGUAAGAAGGUGGGAUCCACCGACUUUACCCACAUUCCCGCGCAGCGUGCGAUAAGGCGACGGGCCGGCGGUGAUUAUGAACAAAGUCCGGUGUUUUCCCUCUGUCCGUUUUCAAACGACACUGAACAGUUACUAACCAGGGACUAUCUGGUCCAGAUCUGCAAACACCUCACUGAGAGGCAGCUACGCACUCCCGCACUGCGUUCUACGAUAUCGUUUGGACGCGGAUUUUGGAAGUUAUGUACCAUUGUUGAUACUAGCAAAGUUACGGUACAACAGACUCUGUCUCGUAAGGCCAGACUCGCGGUGGCCCCUACCUGCGAACACGAGCUAACACACAUUACGCGUUGGACAAGUGUCCUCAGGCGGCUGCUGGCUUGCCAGAACUCAAUUUGGUGCAUUUACAAGCGUGGCUGGGGGGAUUUUACACGCGGACCCCAGACGAACCCCGAGAAUGUCGCCCCAGUAUUAGCAACAAGCACGCGCCCAACCCCAGUACACUGCGCACUCCGGCCCGGGUUGGGAAAGUCGUUGAAGUGGCGGCUCAAUCAACACAUGUCGUACGCGCCGCGUUUCGGCACCAUGACGCGAGCCCAAUCAGCUAACUUCCCUAUCCCCUCUGCUACUUGGGGUCUCACACAUUAUCGCACCCGAUGCCGACGUACUUGUUACGUGGCCCAUAGCUCGAUAUGUGGUUUUGGCCGCUGCGCAUCAUUCAAUAGGGUGUUCAGGUUGUAUUACUGUAGAAAUUUGAAGUUACGAGCAACGGUUCGCAGUCAGUCGAGCUGCGCUCGAGUGGUGCUUCGUGUCAACGCCCACCCCAACGGCGUCGUGAGAUCCCUCUCGGGGGACCGGGGGACUUUCUAUUUCUUGGUAUUAUUGACUAACGGCGAUAUGAAGGACCCCUGGAUUGUAGAGCAACGCAACAGCGGUAACGUCAAGAUAAAAGCUCAAGGAGCGGUGUCACUCGUGAGAUGGGGGGAACUUGGGGUGGGUGAUGGAGAGACUACCGCCCUAGGGACUCGAACAGUGUACACGAGCAUGCCACACUACUUUCCCCUGCAAUUUUAUUGGCGUGAUAGCACGCAACCUGUAUCAGCAAUCAUUGGCCCUCGUAUCCUGUUAUUGAUUGCCCCGAACUUAAUACCUCGACCAUUAUCAAAUAUCGCAGGAUCCCGCACGAAUGCCCGUAACGAUUAUAUAAAGAGUUUGUCUCAGUGGAAACUCACCCGAAGACGGACGAUAGAACGAAUCAGACGUAAAGUGGCGGUUACAACGUUUGCUCUACCGUCCAGCCUUUCCUCCAGACUCCAACCCGCCCUCAUGCGCGUCCUAGGUUCACCCUUGUACUCAGUGGCCAGUGGACUCUGUGUACCCGUUCCACCCUCAAAUCCACGGAAUAUAGAGAAACGUUGCAGCCAAAGGCGUAAUCAUUCUCCAUUAGAGCCCCUCGCGUCACUCAUAGAAUUUAGUCUCAGUCGAGUCGGUAAAAUAGUCUGCCUAAAGGUGGAGCUGGCUUCUUGCAGCGCUCGUAAAUGGGAAACUGCUUUUAGUCAAUACAGCAGGUACUACACAAAGAGGGCAUGGACCAUGGACACGGAGACGAUACACUAUUCACAAGAACCAUCGCGUAGGGGAAUAGGAGCGCUCUUGCGUGCACCCUCCCGCGUCCCGCUCCUACGCCGGGUGGUGGAAAAACCCAACCAAUGGCGAACUGCGCGCCCAUCGAUUGAUAGUUCUAGAGAUUUAAGAUACGUCAAACCGAUUCGGCUCGUAUGGCCACUGGCGUACUCGCCCAGCCCGGUCGGAAAAGCGUUCCAUUUUCGAUUUCUUAGAAUAAGUCAUGAUACUUUCCUCACCACUGACCUAAUGGUACAGAUGACUUUUUCUUGUCAUGCACAAUGUAUGACAUUCCCCAUGGCCGACUGGCAGGUCGUCAAGAAAAUUGGCCGGGGAACACUUAAGUUGGUUACGUAUACAGUAAAUAGCACUUGGAGACGCAGUUUACUCCACUACCAUGAGCAAGCUGCGACCCUAAGGUUAGCAGUAAAGUCCAGUUUCCGCGCCCCUGUUAAUUGCGUAUUUUGUUCUAGUCGAUGGCACAUAGUCUGCUGGCUUUCCGUUUUGAGAGUUAUAAGUAGACCUUUUUCGAUCAGCUUCACACAUAGCAGUAUUUUAUGGACCACAGGCCAUGUCCAUUUGAGUGCCAUGGACGCUCCAGGUGUGAAUGAUAGAGUUAAUGCGGCGUACCCCGUCAUAAGCAAUCAAUGGGGACUUAUGCUUAGGCGGACACGCAGCAUAGAGUACUCUUUCACCCUAACUCACUCACGCGGCUUGCAAUGCUUAUAUAAUACUUCUCGGUAUGUAGGAACCGCUGCUGUGCGCAGAGGCCACCAAGCUUGUCAAAGUGAGCAUAGUGAGGGCGGCCCACCCACCGUUGAUCGACUGCUCUCGGCCCUGUUAACCACUGCAGUCAGGCCGAAUGAGAAAUCUCUCGUCACGUCAUAUCAGAACCCUGACGAACUAAAUUCAGAUGACUCGCUAAGGUCUAUCUCGGUGCAUCUCUAUUUCCCGGGCCUAGAACACAGAAUAUCGACUUCGCUCCAAAUUCCUGGCGGCUGUGUAGUAAGAACGUUCAUGGGCAUGAACGUGGGCGUUUACCAUAGCUCCACAACGCACCCGUGUAUCGCGUUCCGGGGCCAGUGUAACAAAGUUUCGAUCGCUCAAUUCUGUGUUUUUAACAAUUCGCUCCAAUUUCGCGGGCAUAGAGCACGCACCGGUGUCAGAUAUCAAUACCUUGGAGGUAUGUCUUUCUUUUAUUCCCAACUGGGCGUUGUUCUAGCGCCACAGAGGUCGAAGAAUCGCUGGCCUCUACGUCCCCUCGCGUCCAAUCCUGUGGAGGCAUGCACUGUAACUGGCCUGGACAGCACACCGAGUGUUGGGCCCACUUCCUGGUGUCAGUGUAUGAAUUACCUCUUGGUGAUGUUCGAAGGGUCCCUCGGCUUGUCCACUUCUCAUUCGGGAUCCGGAUGCAUUGGUUCGUGCGGGCCACGGUUAUUGCAGUGUUUUCCGCCAACCUUGGGGACUUACACGUUGGUCGCUCCCAACGAAGCUCCGGGUCCUGAAAACGUCUCCACAUGGCUGAAACCCCCCGCUUGCCAGAGUGAUCUGCCCAUCGAUGGCAUUUCACGUGUUUUUAUUCGCUGCCUCUCCGACCCCCGUGUGUCCUCAUUCGCAAACGGAUCCCGAAGUGGCUCUCGAGACGCUGACCUUUGCGACUCAUUAAGAUUCCAGUUACGUUGGUUCAGAGUUGCGCUCGGAAGGGUGUCGAAAAACCUACGGUUCGCACAUAGUUUAGACAAUAAUUGCCCGCCUGUUACUACAGAACGGCGUCACAGGAUGCUUCCAGUCCGCCAACUAAUUUGCGUAUGGUCCUGGGAACGCAGGCACGGCACCGGUGUCAAGCCCCGGUUUGCUCAGUUGAACCUGAAUGGUACCGAGGGGGCCGCAGUAGUCACAGACGGAUCCCCUAACCCUUUAACACCCACGAGCAAGGGAAAGACGCUAGAAAGUGACCCUCGUCUAAUCGGAGGUGGACGACCGCAGAUACAAAGCAGUAUCGUUGUCUGCGCCCCCGCCCUCGAGUUUCGCAGCCAACUCCGUUUAUGGGUCACCACAUCGCAAGAGCACAACUACGAAAUAUAUCACCAGACAGCGGAAUGCGGACUGAAUUUUCCAUAUUUGUGUGUCUUGCUAUAUUUAUCGUUAGGGCUUUUACUGUGUGAUGAAGAGCACUCUAAAGGAGGUGUGAUUGUCAUGAAUGAACAACUACGUGAUUCGUAUCAAGUACCUCUCCUGUUUGCUGUCUCAGUAGGGGGCCUGCCACCGGCUUCUCUCCGCAGCAGUCGGGGUCGAAAAGGCACUCUUAUAAAAGAACCCACGCUCCGCACGCUGAUCAUCAUAAAUUCCAAGAUUAACGUGCUGAGUGUGGCCACCAUUAUACAGGACAUGGGAAAUAAGCGCCCGCGCGUCAACGAAGGUGGCCGUUUCCCGUGGCAUAGACGAGCGGUAGUUUCUAACUCACACAGUAAACGAGAAACCGGACACACCGGAGUGGAAGCUUGUUGCUACAGAGUCCCGCUGUGCGAGCCCACAUUGGAGGGCGGCAAUGGGACUUCAGUGGGGCUUCAAGGCCGCCCACACGUAAUCUCUGCCACGAUGGUAGAUUGGAGCGGCCAGCUAAAUGCCGACAGAGUAUUAUUUAGACUCUAUGCUAGGAAGCAAUCGCAACCUCCGUCAGACGCACUGCUUUAUCGAUGCCAGCAGCGUUCUCGGAGGGUCUUGUUGGAUGUGAGCACGCCCACCCGUCUUACCUACCCUUUUCGCGCUCAAAUUAGAAAUGAGUCGUUGAAUGUCAAUCUAUUGUUUGAGUGUUACACCCGCAACAUCUCUGUAUACUUGGCACAAAACCGAGUAGUUCUUUCGUAUUGCAUAGCUGAUGCUCGGGUUCGUGAGAUGCGUUGCACCUAUCAUUUUGCCGGCCUUAAGUCAUCAGCUCUUUUGUCAGUGAGUAUGCCUCUGAGUAGACUCAUCGCCAGAUUAUAUCACCCUCCCCGGAGAGGCCAAACCGCAUUCAAGUCUCAUGAAAGCGUGAACCCGUAUGAUGAGAGCGGCGUUGUCAAUGAAUAUGUGACCACAGUAAGCGUAUAUCGUUUACGGCCGUCUAGUAGGAUUGUAGUUUCUAGUUGGCCCGAACUGCAGGAUAACUGGUGGUCGAUUAUGAAGCACCCAGUAGUAGUUUGUGAGGACAUGAAAAUUAAGUCACACUGGAUGAACAGUUGGUCGAAAUUGCAAGCUGGGUGCAUGAGUAGACGCCCAGUAACCGGAAUAAAACAAAGUGGAUCACGCCAGGAGUUAUCGCGGAAGGCUAGCUUUUUGCCGAGUGGUAAUGAUGAUGCGUAUAACAACACGCGGUUCUCCAGGUUGCUACUUGAUCACUGUCCGAUACGCCGCACGUGCCGGGCCGUGAAGCGUGCCCUCAAGGAUAUUACCUCGGUUGCACAGUCUCGUGCGAUAGGAACUAGUAUGUUAAUCGCUAAUGCGCGUGCCGCGGGAAGCUACCGACCAUGCUACUGCUGGUCGAAUGAUGUACACAAGUCGCACUCGACCUCCUCGAAUCCGAGGCAGGCUUCUUUCAUAGGAGGGGCACAUGAGACUAAGUCUCUCGCAGGCGUACGCUGGUGCCGAGCCCCUCGCCAUGGGUAUAGUCCAUCUUACAAGUUGCGAUACCCGACGCAAGACGGUCUUCUAGCAACUCGGCAUGCCCGCAACACUGCUAUCUUAACGGACCAGACAAAAUUGUUAUGGGCCAAAAUGGCUAGUACGGGCCCAGGCUCCAUUAAAUCGAUUGCCUCCGGAAAACUUUCCAGCGGUGGCAGUUCAACCAAGGAUGACCUUCUGGUAAUCAGUAUGAGAUGGGUCCCCACCCUUCAUUCGGAAUCUAGCCCGUGCGAAUGGGGUCUAGAGCUCUCGAGUAAGGUUCGAUGCACUAUGUCGAUAUAUGCCGAUCUCCUACGGUUAAAUCAAGUACCAGUACGACGAUAUAAAGCUUGCCUAAAAAACUGUGUUUCAGAAGAAUGCGAGGAUACUACUUACCCUGAGGGGUCGCACGCACGAGCGUCAAAACGGCCUAACUUUACUACAUGCAGGUCACAUACGUGGUGGGGAUGGAAUGAAAUAUCGGGAGUUUAUGCAUUUGCGGCGAAGUGCUCCAGAUGCCUCAGGUACUUUUGGGAACCCACUUAUGGGGAAAGUACGCGGAGAGAACUUGGCUCGAUAUUUUCCUGGCUGCGCAGUAGAAAUACAAACUUCCGGGACCAUUAUCCGGAUUUGGACCCGCGGAUCAAGACAAGAAGUCUGAUGUGGACGUACGGUUUCCAAAGGGAGCAUAUAAAAAAACGGCCCACUAUCCUGAUGAGAGAAAAGAGCCCUGGAUAUUGUCUCAGUUGCCACGGCAUUUGGCGCGUCUCGGUCCCGUGCCCACGGACGAUUCACAUUGGACUCCUCAGGAGCGUUAGAAAAAAACUGCGACAGACGAAACCUGACCAGCUGGGCACAAGUACCAGUAUAGCAUUGCUAUCGUUAGUUCUGGUUUUCGGUGUCACCUAUCAUACCGGUCCACGGCCCCAUGGAACAACGUCCAGAGGUACGGCCAUUCUGAAGAUCAAAUUCCCGGUUGUUCGUCCUGUGCAACUUGUGAUACAUUCAGACACCUACAACCCCUUGUCAUUCCUCAUGACUGGAAGGGGCACGCGGUGGACUAUGCCAAGCAUCACACAAGCCUUGGCCGCGAACGCUUUCCUUCUACUCUCCCACAGUCCGUUUGAUCGGUGUCAGGAGGCAUCUUGGAGGUUCAGAAUCUCACUACGGGCGCGAUCUAAAGACCCUAGUGGCCGUCCAUCAUGUCCACCUAUGGUGUACCGGGCGGCCGCCAGCUACGAGUGCUACCUCUUUACCGUUUCGAAGUUCCAAGCCCUUUUCCCCCUGACCCCUCUUCUUGUCCCUCAGAGCCAAGAGGCGCAUGGUAAGCCACAAUACUACAGUUCCAGCUCCUUUGUGAUUUUGGCUGUGUACUUAGGAUACCUGCUAGGAUGGCGCAAUCCGCUACCAGAGCCUCCGAUAAGCGUAUGGAAUUAUCCAAGACGGGCACAGCGACGAUUGCGCAAAGGAGUAAGUGCCAAGGGUCUCCAAAUCCAAACUACCAUGCCGUAUAAUAAACAGUGUGGUAUGUCUGCCGAUUGUUGCUUGAGAUCUGAGAGCCCCAGCCCUCCUUGUGCAGUUACCGCCCCCACAUUCCGUAUGGUUCUCACAACACAGGCAGCCCGACGACUGGUGGCAGAUGUCAUCGUGUCAGUGGCUUGUCAUACGUUGCCUAGUGCACCGCGUUUCCAAGAAUUGCUCGUCUGUGAAGGAGGGCUCCUGGGGAAUCUAUGCGAUAACGCCCGCCUAGUCUACUCUGUCGCGUUUGCCGUGUGGCCUCCACCUCCAUAUACCCAACAGCUGAUUACGCGAUUAGCAGCUGUUACGGGACGAGUCGGAAGCUUUAUAAACGUAUCCUAUGGAAUGGUUACUAAAUUCCAUCCUCCGGCACGCGACCACAGCGAUACAGUAUCUGGGGGCAGCUCCACGCCAAGCACCGGACAGACAAUCAAUGCCCCUUGGGUCACAUGCACGUUCAUCCAUUAUUCACGCAGAAACAUGUAUAUGAUGCAUGAACUAUCGCCGGGACUUCGACUUUCGGAUUUUGAAAGUCCGUCGUUCAUAGGUGUAUUCAAACUUCGUGCUUCAUGUGUUCGUGGUUCCCCAAAAUGUUUAAGGUCACUGGGCGCGGCGAACUCGGGCCUAGUAUCACCCUCGGGCCGCGAAUCCGUCAUACGCGACGAACGUGCGGGAGCCCAUUCAAAGAGCCCGAAAUUGUGCUACAUAUUGGAUCAAGGGCUCCGUGAACGAGGGGACUCAACUACUGCUUACGCUUGCAUGAGCAGUAGGCAAGCACGUUUUACGGUGUACCUACGGUCAACAUAUAAAUUUGUAGCUAGUAUAUCGAAUUCUCUGAGGAAAGAAAACACGCUCGAAUGCCUGAUCUCACAGUUGUCUGCCGGUAGUGUGCUUUUUCCAACCCAAUCCCUCACCUCUGAUCACGGGAGAUCUACAGCUUGUCGUAGGCAAGGCAAUUUAGCACACGUCGUCACAAAGCGACCUAGACAAAGCAAGGGAACUGCUCCACUUCCAUGUUUUCAUAUAAAUUUCGCCCUCCCUCACACCUGGGUUACCCAAGUGCUUGAACAAUUAUGUCGCUUUCUCGACGAUUUAGGAGCAUGGCCUGCAAGUCCGACUCAUAAUUCACAGCAAAUUUACCCACGUGGGGGUCUGACACGUGCAAUAGAGCAUCGAUUUGCUACAACACAAGUGCAAGCUCCAUUCGUAGAUAAGCUAUGCCCGGGCAGUCGUCCGUCGCAACGAACUGAACAUUCGACAGUACAACCCGGCCUUUUGUUUGCUAACAUCGCGCGUGGCCGAACCAUGGUAAUGCCAAUAAGCCCACACCCCAAGGAGUUCGUCAUGCAUUCCAGGCUUGCUACAUUUAGCCGAUGUGUCCGAGCUGGUAGGGAACGCGGUGGGAUCCCUGCCGGCGGGGCUGUAUAUUUGUGGUCUGUACGCUCCCGGAAAGCUUAUGGAGAUGGGAGGACAGGUUGUCUGUUCUUGAGCAGGGGCACUAAACUUCGCCUAUGGGGGCAAUCCGAAUGUUCUGGAUUCCAGAGUGAAGAGUUCCCCAGGUUUUUGAACCCACCGAACGCCUGUGGAGUAUACGGAGUUGAUCCAGAGAAGGGCCCAUAUUUCACUAAACAAGGCUUAGACAUGUGCCAGUAA"

from typing import Dict

def rna_to_protein(rna: str) -> str:
    codon_table: Dict[str, str] = {
        "UUU": "F", "UUC": "F", "UUA": "L", "UUG": "L",
        "UCU": "S", "UCC": "S", "UCA": "S", "UCG": "S",
        "UAU": "Y", "UAC": "Y", "UAA": "Stop", "UAG": "Stop",
        "UGU": "C", "UGC": "C", "UGA": "Stop", "UGG": "W",
        "CUU": "L", "CUC": "L", "CUA": "L", "CUG": "L",
        "CCU": "P", "CCC": "P", "CCA": "P", "CCG": "P",
        "CAU": "H", "CAC": "H", "CAA": "Q", "CAG": "Q",
        "CGU": "R", "CGC": "R", "CGA": "R", "CGG": "R",
        "AUU": "I", "AUC": "I", "AUA": "I", "AUG": "M",
        "ACU": "T", "ACC": "T", "ACA": "T", "ACG": "T",
        "AAU": "N", "AAC": "N", "AAA": "K", "AAG": "K",
        "AGU": "S", "AGC": "S", "AGA": "R", "AGG": "R",
        "GUU": "V", "GUC": "V", "GUA": "V", "GUG": "V",
        "GCU": "A", "GCC": "A", "GCA": "A", "GCG": "A",
        "GAU": "D", "GAC": "D", "GAA": "E", "GAG": "E",
        "GGU": "G", "GGC": "G", "GGA": "G", "GGG": "G"
    }

    protein = ""
    for i in range(0, len(rna) - 2, 3):
        codon = rna[i:i+3]
        amino_acid = codon_table.get(codon, "")
        if amino_acid == "Stop":
            break
        protein += amino_acid

    return protein

# To compute and print the result
print(rna_to_protein(rna_string))

"""#**mRNA**

##Inferring mRNA from Protein

Problem
For positive integers a
 and n
, a
 modulo n
 (written amodn
 in shorthand) is the remainder when a
 is divided by n
. For example, 29mod11=7
 because 29=11×2+7
.

Modular arithmetic is the study of addition, subtraction, multiplication, and division with respect to the modulo operation. We say that a
 and b
 are congruent modulo n
 if amodn=bmodn
; in this case, we use the notation a≡bmodn
.

Two useful facts in modular arithmetic are that if a≡bmodn
 and c≡dmodn
, then a+c≡b+dmodn
 and a×c≡b×dmodn
. To check your understanding of these rules, you may wish to verify these relationships for a=29
, b=73
, c=10
, d=32
, and n=11
.

As you will see in this exercise, some Rosalind problems will ask for a (very large) integer solution modulo a smaller number to avoid the computational pitfalls that arise with storing such large numbers.

Given: A protein string of length at most 1000 aa.

Return: The total number of different RNA strings from which the protein could have been translated, modulo 1,000,000. (Don't neglect the importance of the stop codon in protein translation.)

Sample Dataset
MA
Sample Output
12
Hintclick to collapse
What does it mean intuitively to take a number modulo 1,000,000?
"""

# dataset
protein_string = "MATWREKFKDEGLWYVTGVMYKPFSCVASRDNRSFCYQSYYNYLVSNLTHRAQGKCTAMFFIACQYFTQMHHKQFAKAENWYIHVHTTYWTIHTEMNTANPTAMEMHQILEWMPFRQPEMIACIQGMFRHQKVAAHRKIQHASVEMCYQHYKGQDCWSHMWEYLILSEKDAKQAAFSPYSCQDHQAMPPGLGELLKFPSYLEHRSTERSELVIEFLKEDCFGGVMAGTRYFPWYDRWVRHLHLNDALSGKYRDNMQRNCLLRCVHFIYPWAIHSKICQYCHYYWMKPCCLAEEIHPGGMAKCNVQPNFYCAIGGECGALRKYKGFFPSKSVMGVDCHPNEKHCWKCEIMEFFPIMDGCVRMAVRIAYIWNGINGHTACRTAHFEKERTWCIHKIPVWLPTYCCTNRQSGEQYYFIVHHHSYWSYELNKHCDHYVFELTYRISGRLGMKFEDTGRQSPFSPPAVDAKAGRRADEFNMIHWMTEQHCDNVTETKLQICKLAYWRREFRLAAREVYDRRLSPPVASGHYQSLILSNWETPQKEIVEYYHTGGCGKCIHFLLPCVDIVKIECWQQFVKIIDGCANHAMWESCGCNMRFSFDTKKKCGFYHVFIPSHGNCASQPSGKRGMQFMCTLEKQLDYMICGKWLVFEWTNPSKRGYGGESAYIENDKCAVHKCFMRFRRDEDKIPWFCEQYHDVHDQDEWGILFKINMGAGHDTVTTLYWFCMYWLQMMMIVYESRWLPADHGPFPDWCGHEMFHVAWGSDNQSIFHNPKYTCLFSRQGQTESSKAMKLALISVAMIYVQFPAPTLSNILLVNFSQLNFVEQWWWYLLPSDVNIMPLIIDLWATAIPGSVQQDICCDINSVKLTKMKQNMHPPVPDAKPLQQFIFVWCDYQYQDIMRIGMQVWTKFCLCPAYCWAWGYMKLTHNLECWCGVLSYEVLHHNDPPVVLGWMRFDEQREKHWQIATVKDIWNISMLTYHECDTMQFQGPDHTRGKRTVSNH"

from collections import Counter
from typing import Dict

def protein_to_rna_count(protein: str) -> int:
    codon_table: Dict[str, int] = {
        "F": 2, "L": 6, "S": 6, "Y": 2, "C": 2, "W": 1,
        "P": 4, "H": 2, "Q": 2, "R": 6, "I": 3, "M": 1,
        "T": 4, "N": 2, "K": 2, "V": 4, "A": 4, "D": 2,
        "E": 2, "G": 4, "Stop": 3
    }

    total_count = codon_table["Stop"]  # this accounts for stop codons
    for amino_acid in protein:
        total_count *= codon_table[amino_acid]
        total_count %= 1_000_000  # Applying the modulo 1,000,000 at each step

    return total_count


# To compute and print the result
print(protein_to_rna_count(protein_string))

"""#**PERM**

Rearrangements Power Large-Scale Genomic Changesclick to expand
Problem
A permutation of length n
 is an ordering of the positive integers {1,2,…,n}
. For example, π=(5,3,2,1,4)
 is a permutation of length 5
.

Given: A positive integer n≤7
.

Return: The total number of permutations of length n
, followed by a list of all such permutations (in any order).

Sample Dataset
3
Sample Output
6
1 2 3
1 3 2
2 1 3
2 3 1
3 1 2
3 2 1
"""

# Dataset
n = 6

from itertools import permutations

def generate_permutations(n: int):
    numbers = list(range(1, n + 1))
    perms = list(permutations(numbers))

    print(len(perms))  # To print the total number of permutations
    for perm in perms:
        print(" ".join(map(str, perm)))


# To compute and print the result
generate_permutations(n)

"""#**FIB**

#Rabbits and Recurrence Relations

Wascally Wabbitsclick to expand
Problem
A sequence is an ordered collection of objects (usually numbers), which are allowed to repeat. Sequences can be finite or infinite. Two examples are the finite sequence (π,−2–√,0,π)
 and the infinite sequence of odd numbers (1,3,5,7,9,…)
. We use the notation an
 to represent the n
-th term of a sequence.

A recurrence relation is a way of defining the terms of a sequence with respect to the values of previous terms. In the case of Fibonacci's rabbits from the introduction, any given month will contain the rabbits that were alive the previous month, plus any new offspring. A key observation is that the number of offspring in any month is equal to the number of rabbits that were alive two months prior. As a result, if Fn
 represents the number of rabbit pairs alive after the n
-th month, then we obtain the Fibonacci sequence having terms Fn
 that are defined by the recurrence relation Fn=Fn−1+Fn−2
 (with F1=F2=1
 to initiate the sequence). Although the sequence bears Fibonacci's name, it was known to Indian mathematicians over two millennia ago.

When finding the n
-th term of a sequence defined by a recurrence relation, we can simply use the recurrence relation to generate terms for progressively larger values of n
. This problem introduces us to the computational technique of dynamic programming, which successively builds up solutions by using the answers to smaller cases.

Given: Positive integers n≤40
 and k≤5
.

Return: The total number of rabbit pairs that will be present after n
 months, if we begin with 1 pair and in each generation, every pair of reproduction-age rabbits produces a litter of k
 rabbit pairs (instead of only 1 pair).

Sample Dataset
5 3
Sample Output
19
"""

# Dataset
n, k = 34, 4

def rabbit_population(n: int, k: int) -> int:
    if n == 1:
        return 1
    elif n == 2:
        return 1

    prev, curr = 1, 1
    for _ in range(3, n + 1):
        prev, curr = curr, curr + k * prev

    return curr



# To compute and print the result
print(rabbit_population(n, k))

"""#**SIGN**

#Enumerating Oriented Gene Orderings

Synteny Blocks Have Orientationsclick to expand
Problem
A signed permutation of length n
 is some ordering of the positive integers {1,2,…,n}
 in which each integer is then provided with either a positive or negative sign (for the sake of simplicity, we omit the positive sign). For example, π=(5,−3,−2,1,4)
 is a signed permutation of length 5
.

Given: A positive integer n≤6
.

Return: The total number of signed permutations of length n
, followed by a list of all such permutations (you may list the signed permutations in any order).

Sample Dataset
2
Sample Output
8
-1 -2
-1 2
1 -2
1 2
-2 -1
-2 1
2 -1
2 1
"""

# Dataset
n = 5
from itertools import permutations, product

def signed_permutations(n: int):
    numbers = list(range(1, n + 1))
    all_permutations = list(permutations(numbers))
    sign_combinations = list(product([-1, 1], repeat=n))

    signed_perms = []
    for perm in all_permutations:
        for signs in sign_combinations:
            signed_perms.append([perm[i] * signs[i] for i in range(n)])

    print(len(signed_perms))
    for perm in signed_perms:
        print(" ".join(map(str, perm)))


# To compute and print the result
signed_permutations(n)

"""#**PRTM**

#Chaining the Amino Acidsclick to collapse

Figure 1. Formation of a peptide bond

Figure 2. Outermost acids
In “Translating RNA into Protein”, we examined the translation of RNA into an amino acid chain for the construction of a protein. When two amino acids link together, they form a peptide bond, which releases a molecule of water; see Figure 1. Thus, after a series of amino acids have been linked together into a polypeptide, every pair of adjacent amino acids has lost one molecule of water, meaning that a polypeptide containing n
 amino acids has had n−1
 water molecules removed.

More generally, a residue is a molecule from which a water molecule has been removed; every amino acid in a protein are residues except the leftmost and the rightmost ones. These outermost amino acids are special in that one has an "unstarted" peptide bond, and the other has an "unfinished" peptide bond. Between them, the two molecules have a single "extra" molecule of water (see the atoms marked in blue in Figure 2). Thus, the mass of a protein is the sum of masses of all its residues plus the mass of a single water molecule.

There are two standard ways of computing the mass of a residue by summing the masses of its individual atoms. Its monoisotopic mass is computed by using the principal (most abundant) isotope of each atom in the amino acid, whereas its average mass is taken by taking the average mass of each atom in the molecule (over all naturally appearing isotopes).

Many applications in proteomics rely on mass spectrometry, an analytical chemical technique used to determine the mass, elemental composition, and structure of molecules. In mass spectrometry, monoisotopic mass is used more often than average mass, and so all amino acid masses are assumed to be monoisotopic unless otherwise stated.

The standard unit used in mass spectrometry for measuring mass is the atomic mass unit, which is also called the dalton (Da) and is defined as one twelfth of the mass of a neutral atom of carbon-12. The mass of a protein is the sum of the monoisotopic masses of its amino acid residues plus the mass of a single water molecule (whose monoisotopic mass is 18.01056 Da).

In the following several problems on applications of mass spectrometry, we avoid the complication of having to distinguish between residues and non-residues by only considering peptides excised from the middle of the protein. This is a relatively safe assumption because in practice, peptide analysis is often performed in tandem mass spectrometry. In this special class of mass spectrometry, a protein is first divided into peptides, which are then broken into ions for mass analysis.

Problem
In a weighted alphabet, every symbol is assigned a positive real number called a weight. A string formed from a weighted alphabet is called a weighted string, and its weight is equal to the sum of the weights of its symbols.

The standard weight assigned to each member of the 20-symbol amino acid alphabet is the monoisotopic mass of the corresponding amino acid.

Given: A protein string P
 of length at most 1000 aa.

Return: The total weight of P
. Consult the monoisotopic mass table.

Sample Dataset
SKADYEK
Sample Output
821.392
"""

# Dataset
protein_string = "VMWNWSYYYEQVRWIHLFFKPRQSRSEIKVLIENGICGPTATSWNVDWKGESQFFYMMWVVQPGQALHSYAWFIDCSYWMVQSYIVCYFPFEKATEECTYKDWPEEFCMGTTALFINVAFGLLRLFCERDLSIAQPGCQNPCKQQPDELVPRDNLLSGLRNQSVECETNWWIYPNTRSDNQIENTAGIKAIWRFYTAWNCKMVRYRLYIWIENWGQTGPGSETRGLCYFFYYETIKAWPIAAREHRIWFMTSFQIHSICNMPVQCMYALHVIWIHAAAHEVAAHPFHTTIYNDEYWELPRFNHGFGTGKHCSCPMVVRAGANQIAFLSQNKGNNLRKAIMNINMCRKPWFCKIRCKFDGEQWWCLHQHICNTFTSKNVDNCMDRNCLLEDKMAPHACQFLGEIGPAAHLLHEMLGAIDLRAFNTILGTDSKSICQFSPQTIQCSNCYDLFGGWVPMGRVCLVEYSTHKVKIKMLWQQDVYWSWRFDKRMLEHDDMSVRPLLCEVISCQLPLMERDRDILITGKSDPVVQFGITEGRGSRKEVYQCQTQFQTFAINLANTNMCHPEICIGYQYSCKHIYCFVPDGSTWTWAQRDDYSFGTWVRGPTWVPAMMIEYETCYRWKCDPWKRPLDNEHCKQFWTLHAQHAPHKWIPKWAMGRPTVVLYFITKHCWLKGMNRWSRRAHDRGFATNNIKEFHCPQGDQAKMCDPFFMWNSTIPVFSMNKSYTGEFPKTYILKNGRWMYEYDNTYPMNFNSMMNTDMDYEYRCKKVCNDHMLSDVDGTRGPELCPNYWCAWRYHGEDVTKYMFAYYATEMHYIRYCVCSPAESMYPPGLFFKCCHFDAEVDADWRSTCKMILQVPKAKYNFFLRAFDKQCDMAICTIVAHRCTSNKLERCQNYTFKMGNGWDRADSGCQKCFFYLGMRCPDNTMGSLIYM"
def protein_mass(protein: str) -> float:
    monoisotopic_mass_table = {
        'A': 71.03711, 'C': 103.00919, 'D': 115.02694, 'E': 129.04259,
        'F': 147.06841, 'G': 57.02146, 'H': 137.05891, 'I': 113.08406,
        'K': 128.09496, 'L': 113.08406, 'M': 131.04049, 'N': 114.04293,
        'P': 97.05276, 'Q': 128.05858, 'R': 156.10111, 'S': 87.03203,
        'T': 101.04768, 'V': 99.06841, 'W': 186.07931, 'Y': 163.06333
    }

    return sum(monoisotopic_mass_table[aa] for aa in protein)

# To compute and print the result
print(round(protein_mass(protein_string), 3))

# -*- coding: utf-8 -*-
"""Edge-Primer Design for a Given Sequence.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/13NeZuUjIhDNrh91X_KzfpXmtJ2LcvpTQ
"""
Sequence= "ATTTCCCCCTTACC"
def primer(sequence: str, primer_length: int) -> dict:
    sequence = sequence.upper()


    complement_table = str.maketrans("ATGC", "TACG")

    reverse_complement_sequence = sequence[::-1].translate(complement_table)
    primer = reverse_complement_sequence[:primer_length]

    return {
        "primer": primer
    }

Primer_Length=5

primer_result = primer(Sequence, Primer_Length)
print(primer_result)

# -*- coding: utf-8 -*-
"""Edge-Primer Design for a Given Sequence.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/13NeZuUjIhDNrh91X_KzfpXmtJ2LcvpTQ
"""
Sequence= "ATTTCCCCCTTACC"
from re import S
def primers(Sequence: str, primer_length: int) -> dict:

    Sequence = Sequence.upper()


    complement_table = str.maketrans("ATGC", "TACG")


    if Primer_Length > len(Sequence):
        return {"error": "Primer length exceeds sequence length"}

\
    forward_primer = Sequence[:Primer_Length]


    reverse_complement_sequence = Sequence[::-1].translate(complement_table)
    reverse_primer = reverse_complement_sequence[:Primer_Length]

    return {
        "forward_primer": forward_primer,
        "reverse_primer": reverse_primer
    }
Primer_Length=5

result = primers(Sequence, Primer_Length)
print(result)

"""SUBS/PRTM/SPLC/REVP/TRAN/LCSM/ORF/"""